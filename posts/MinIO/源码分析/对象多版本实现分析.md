# 概念
前面我们分析了对象读写的基本流程，现在让我们更深入一点来探索怎么实现对象操作的高级特性。
首先我们来简单解释下各个概念：

- 多版本：默认情况下，对唯一对象名的每个新写操作都会导致覆盖该对象。你可以开启versioning来保留每次操作的版本。多版本是对象锁定和保留期限的前提条件。
- Object Lock：
   - 借助 S3 对象锁定，您可以使用一次写入，多次读取 (WORM) 模式存储对象。
   - 使用对象锁定，每个对象都可以通过legal hold或retention period或两者的组合来锁定。
- 保留期限（RETENTION PERIOD）：
   - 保留期限是一种保护层，可在用户指定的固定时间内锁定对象。根据用户提供的Retain until Date锁定对象。在保留期限到期后，便可覆盖或删除对象版本，除非您还对该对象版本施加了legal hold。用户可以选择两种具有不同保护级别的保留模式（RETENTION MODES）：
      - compliance（合规模式）：不允许任何用户（包括root）覆盖、删除或更改对象锁定状态
      - governance（监管模式）：除非被授予特殊权限，否则用户不能覆盖、删除或更改对象锁
- 合法保留（LEGAL HOLD）：
   - 合法保留是防止对象被删除的另一层保护。合法保留锁定对象，直到它们被手动移除。任何拥有s3:PutObjectLegalHold权限的用户都可以应用和删除它们。
   - 合法保留与保留期限没有关联。对象版本可以同时具有保留期限和依法保留、具有其中任何一个或不具有任何一个。

对象锁定仅适用于受版本控制的存储桶，保留期限和依法保留则适用于单个对象版本。单个对象的不同版本可以具有不同的保留模式和周期。
当您锁定某一对象版本时，Amazon S3 会将锁定信息存储在该对象版本的元数据中。对对象实施保留期限或依法保留仅保护在请求中指定的版本。它不阻止创建该对象的新版本。
如果您将一个与现有的受保护对象键名相同的对象放在存储桶中，Amazon S3 将创建该对象的新版本、将其存储在请求的存储桶中，并将该请求报告为已成功完成。现有受保护版本的对象将根据其保留配置保持锁定状态。

---

# 结构体分析
首先从数据结构的角度来理解逻辑，就像我们研究文件系统时，总是先研究它在磁盘上的持久性数据结构布局一样，理解了这部分，那么对逻辑就自然而然牵连起来了。

## FileInfo
首先来看元数据FileInfo，你最好把每个字段都过一遍。
```go
type FileInfo struct {
	// 卷的名称
	Volume string `msg:"v,omitempty"`

	// 文件名称
	Name string `msg:"n,omitempty"`

	// 文件的版本
	VersionID string `msg:"vid,omitempty"`

	// 指示版本是否是最新的
	IsLatest bool `msg:"is"`

	// 标记已删除的版本
	Deleted bool `msg:"del"`

	// TransitionStatus is set to Pending/Complete for transitioned
	// entries based on state of transition
	TransitionStatus string `msg:"ts"`
	// TransitionedObjName is the object name on the remote tier corresponding
	// to object (version) on the source tier.
	TransitionedObjName string `msg:"to"`
	// TransitionTier is the storage class label assigned to remote tier.
	TransitionTier string `msg:"tt"`
	// TransitionVersionID stores a version ID of the object associate with the remote tier.
	TransitionVersionID string `msg:"tv"`
	// ExpireRestored indicates that the restored object is to be expired.
	ExpireRestored bool `msg:"exp"`

	// 文件的数据目录
	DataDir string `msg:"dd"`

	// 指示此对象是否仍为 V1 格式
	XLV1 bool `msg:"v1"`

	// 上次修改文件的日期和时间，如果 Deleted 为 true，则此值表示被删除的时间。
	ModTime time.Time `msg:"mt"`

	// 总文件大小
	Size int64 `msg:"sz"`

	// File mode bits.
	Mode uint32 `msg:"m"`

	// 文件元数据
	Metadata map[string]string `msg:"meta"`

	// 对象的 Part 信息
	Parts []ObjectPartInfo `msg:"parts"`

	// 所有对象的 EC 信息
	Erasure ErasureInfo `msg:"ei"`

	MarkDeleted      bool             `msg:"md"` // 将此版本标记为已删除
	ReplicationState ReplicationState `msg:"rs"` // Internal replication state to be passed back in ObjectInfo

	Data []byte `msg:"d,allownil"` // 如果内置的话，表示对象数据

	NumVersions      int       `msg:"nv"`
	SuccessorModTime time.Time `msg:"smt"`

	Fresh bool `msg:"fr"` // 表示这是第一次调用写入 FileInfo

	// Position of this version or object in a multi-object delete call,
	// no other caller must set this value other than multi-object delete call.
	// usage in other calls in undefined please avoid.
	Idx int `msg:"i"`

	// DiskMTime 表示 xl.meta 在磁盘上的 mtime
	// 这主要用于检测特定问题
	// reported in https://github.com/minio/minio/pull/13803
	DiskMTime time.Time `msg:"dmt"`
}
```
如果使用了multi-part操作，那么对象会有多个part，每个part记录其编号和大小。
```go
// ObjectPartInfo 对象每部分的信息
type ObjectPartInfo struct {
	ETag       string `json:"etag,omitempty"`
	Number     int    `json:"number"`
	Size       int64  `json:"size"`
	ActualSize int64  `json:"actualSize"`
}
```
另外看纠删信息ErasureInfo
```go
type ErasureInfo struct {
	// 纠删码算法的字符串表示
	Algorithm string `json:"algorithm"`
	// 擦除编码的数据块数
	DataBlocks int `json:"data"`
	// 纠删码的奇偶校验块数
	ParityBlocks int `json:"parity"`
	// 一个纠删码块的大小
	BlockSize int64 `json:"blockSize"`
	// 当前磁盘的索引
	Index int `json:"index"`
	// 数据和奇偶校验块的分布情况
	Distribution []int `json:"distribution"`
	// 保存所有纠删码块的所有 bitrot 校验和
	Checksums []ChecksumInfo `json:"checksum,omitempty"`
}
```
校验信息ChecksumInfo也很好理解，记录算法和校验值
```go
type BitrotAlgorithm uint

const (
	SHA256 BitrotAlgorithm = 1 + iota
	HighwayHash256
	HighwayHash256S
	BLAKE2b512
)

// ChecksumInfo 校验信息
type ChecksumInfo struct {
	PartNumber int
	Algorithm  BitrotAlgorithm
	Hash       []byte
}
```

复制状态ReplicationState我们暂且先忽略不分析

---


# 流程分析
## PutObjectHandler
接下来我们来分析具体代码，入口还是 PutObjectHandler，这次我们关心一些对象本身的写入函数的细节。
checkPutObjectLockAllowed 用于检查对象的lock，因为retention信息是记录在bucket里的，所以这里可以读取出来模式和过期的时间，并保存在元数据字典里。元数据metadata会在putOpts放入opts的UserDefined字段，另外legal hold也是存在这里，所以后面对对象操作时，就可以根据读取的元数据决定操作。
```go
func (api objectAPIHandlers) PutObjectHandler(w http.ResponseWriter, r *http.Request) {
	...
    // 获取桶的属性，并把retention写入元数据里
    retentionMode, retentionDate, legalHold, s3Err := checkPutObjectLockAllowed(ctx, r, bucket, object, getObjectInfo, retPerms, holdPerms)
	if s3Err == ErrNone && retentionMode.Valid() {
		metadata[strings.ToLower(xhttp.AmzObjectLockMode)] = string(retentionMode)
		metadata[strings.ToLower(xhttp.AmzObjectLockRetainUntilDate)] = retentionDate.UTC().Format(iso8601TimeFormat)
	}

    ...
    opts, err = putOpts(ctx, r, bucket, object, metadata)

    ...
    objInfo, err := putObject(ctx, bucket, object, pReader, opts)

    ...
    
}
```
在进入putObject之前，我们来看下ObjectOptions里都有些什么参数（好像也没啥好看的，先注意前几个和版本有关的字段就好了，是否支持多版本是桶的信息，VersionID是请求里携带的），ObjectOptions表示ObjectLayer对象操作时的一些选项。
```go
// ObjectOptions represents object options for ObjectLayer object operations
type ObjectOptions struct {
	ServerSideEncryption encrypt.ServerSide
	VersionSuspended     bool      // 指示存储桶之前是否支持多版本但当前已暂停。
	Versioned            bool      // 指示存储桶是否支持多版本
	VersionID            string    // 指定需要覆盖或读取的 versionID
	MTime                time.Time // Is only set in POST/PUT operations，修改时间
	Expires              time.Time // Is only used in POST/PUT operations，过期时间

	DeleteMarker      bool                // Is only set in DELETE operations for delete marker replication，版本删除的标记
	UserDefined       map[string]string   // only set in case of POST/PUT operations，用户定义的元数据
	PartNumber        int                 // only useful in case of GetObject/HeadObject
	CheckPrecondFn    CheckPreconditionFn // only set during GetObject/HeadObject/CopyObjectPart preconditional valuation
	EvalMetadataFn    EvalMetadataFn      // only set for retention settings, meant to be used only when updating metadata in-place.
	DeleteReplication ReplicationState    // Represents internal replication state needed for Delete replication
	Transition        TransitionOptions
	Expiration        ExpirationOptions

	NoLock                              bool      // indicates to lower layers if the caller is expecting to hold locks.
	ProxyRequest                        bool      // only set for GET/HEAD in active-active replication scenario
	ProxyHeaderSet                      bool      // only set for GET/HEAD in active-active replication scenario
	ReplicationRequest                  bool      // true only if replication request
	ReplicationSourceTaggingTimestamp   time.Time // set if MinIOSourceTaggingTimestamp received
	ReplicationSourceLegalholdTimestamp time.Time // set if MinIOSourceObjectLegalholdTimestamp received
	ReplicationSourceRetentionTimestamp time.Time // set if MinIOSourceObjectRetentionTimestamp received
	DeletePrefix                        bool      // set true to enforce a prefix deletion, only application for DeleteObject API,

	Speedtest bool // 测试用

	// Use the maximum parity (N/2), used when saving server configuration files
	MaxParity bool

	// Mutate set to 'true' if the call is namespace mutation call
	Mutate        bool
	WalkAscending bool // return Walk results in ascending order of versions
}
```

## putObject
因为要支持多版本，因此需要给每个版本分配一个UUID
```go
if opts.Versioned && fi.VersionID == "" {
    fi.VersionID = mustGetUUID()
}
```
对于每个对象，都是先写临时文件，最后再rename，所以都会生成一个临时目录和临时对象
```go
fi.DataDir = mustGetUUID()
uniqueID := mustGetUUID()
tempObj := uniqueID
```
当数据比较小时，数据会和元数据写在一起
```go
for i, w := range writers {
    if w == nil {
        onlineDisks[i] = nil
        continue
    }
    // Data字段可以存放数据
    if len(inlineBuffers) > 0 && inlineBuffers[i] != nil {
        partsMetadata[i].Data = inlineBuffers[i].Bytes()
    } else {
        partsMetadata[i].Data = nil
    }
    // 在multipart上传模式中，partsMetadata要记录每个part的序号和大小
    partsMetadata[i].AddObjectPart(1, "", n, data.ActualSize())
    partsMetadata[i].Erasure.AddChecksumInfo(ChecksumInfo{
        PartNumber: 1,
        Algorithm:  DefaultBitrotAlgorithm,
        Hash:       bitrotWriterSum(w),
    })
}
```
当数据内置时，需要在元数据里标记一下。
```go
if len(inlineBuffers) > 0 {
    // Set an additional header when data is inlined.
    for index := range partsMetadata {
        partsMetadata[index].SetInlineData()
    }
}
```
这时临时对象和partsMetadata准备好之后，就可以开始rename操作了。

## renameData
srcFilePath和dstFilePath是要操作的元数据文件路径
srcDataPath和dstDataPath是要操作的数据文件路径
路径弄好之后，先把原来的元数据读取出来，这里还是二进制格式的数据。
```go
dstBuf, err := xioutil.ReadFile(dstFilePath)
```
然后读取到内存xlMeta里
```go
var xlMeta xlMetaV2
...
xlMeta.Load(dstBuf)
```
然后把最新版本的元数据追加进去，这样就实现了多版本记录了，然后WriteAll将元数据写到临时目录里，这样临时目录里就有完整的元数据和当前版本的对象数据了
```go
xlMeta.AddVersion(fi)
...
dstBuf, err = xlMeta.AppendTo(metaDataPoolGet())
...
s.WriteAll(ctx, srcVolume, pathJoin(srcPath, xlStorageFormatFile), dstBuf)
```
最后再先rename数据，再rename元数据就行了(这样其实还是有部分更新的风险)。
```go
renameAll(srcDataPath, dstDataPath)
renameAll(srcFilePath, dstFilePath)
```

---


# 参考与感谢




